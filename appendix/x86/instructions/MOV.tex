\myindex{x86!\Instructions!MOV}
\item[MOV] \RU{загрузить значение}\EN{load value}. \RU{эта инструкция была названа неудачно 
(данные не перемещаются, а копируются), 
что является результатом путаницы: 
в других архитектурах эта же инструкция называется \q{LOAD} и/или \q{STORE} или что-то в этом роде.}
\EN{this instruction name is misnomer, resulting in some confusion (data is not moved but copied), 
in other architectures the same instructions is usually named \q{LOAD} and/or \q{STORE} or something like that.}

\RU{Важно: если в 32-битном режиме при помощи MOV записывать младшую 16-байтную часть регистра,
то старшие 16 бит останутся такими же.}
\EN{One important thing: if you set the low 16-bit part of a 32-bit register in 32-bit mode, the high 16 bits
remains as they were.}
\RU{Но если в 64-битном режиме модифицировать 32-битную часть регистра, то старшие 32 бита обнуляются.}
\EN{But if you modify the low 32-bit part of the register in 64-bit mode, 
the high 32 bits of the register will be cleared.}

\RU{Вероятно, это сделано для упрощения портирования кода под x86-64.}
\EN{Supposedly, it was done to simplify porting code to x86-64.}

\ifdefined\BRAZILIAN
% TODO to be resynced:
Como curiosidade, vale ressaltar que \MOV é um nome equivocado para a instrução em ambos conjuntos de intruções do x86 e ARM, pois a informação não é de fato movida e sim copiada para o registrador ou variável de destino.
\fi % BRAZILIAN

