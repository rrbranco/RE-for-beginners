\subsection{Умножение, деление}

\lstinputlisting[style=customc]{patterns/185_64bit_in_32_env/multdiv/2.c}

\subsubsection{x86}

\lstinputlisting[caption=\Optimizing MSVC 2013 /Ob1,style=customasmx86]{patterns/185_64bit_in_32_env/multdiv/2_MSVC_RU.asm}

Умножение и деление --- это более сложная операция, так что обычно, компилятор встраивает вызовы библиотечных функций,
делающих это.

Значение этих библиотечных функций, здесь: \myref{sec:MSVC_library_func}.

\lstinputlisting[caption=\Optimizing GCC 4.8.1 -fno-inline,style=customasmx86]{patterns/185_64bit_in_32_env/multdiv/2_GCC_RU.asm}

GCC делает почти то же самое, тем не менее,
встраивает код умножения прямо в функцию, посчитав что так будет эффективнее.
У GCC другие имена библиотечных функций: \myref{sec:GCC_library_func}.

\subsubsection{ARM}

Keil для режима Thumb вставляет вызовы библиотечных функций:

\lstinputlisting[caption=\OptimizingKeilVI (\ThumbMode),style=customasmARM]{patterns/185_64bit_in_32_env/multdiv/Keil_thumb_O3.s}

Keil для режима ARM, тем не менее, может сгенерировать код для умножения 64-битных чисел:


\lstinputlisting[caption=\OptimizingKeilVI (\ARMMode),style=customasmARM]{patterns/185_64bit_in_32_env/multdiv/Keil_ARM_O3.s}
% TODO add explanation

\subsubsection{MIPS}

\Optimizing GCC для MIPS может генерировать код для 64-битного умножения, но для 64-битного деления приходится вызывать библиотечную функцию:

\lstinputlisting[caption=\Optimizing GCC 4.4.5 (IDA),style=customasmMIPS]{patterns/185_64bit_in_32_env/multdiv/MIPS_O3_IDA.lst}

Тут также много \ac{NOP}-ов, это возможно заполнение delay slot-ов после инструкции умножения (она ведь работает
медленнее прочих инструкций).

% TODO add explanation
