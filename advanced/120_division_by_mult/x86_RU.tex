\subsection{x86}

\dots компилируется вполне предсказуемо:

\lstinputlisting[caption=MSVC,style=customasmx86]{\CURPATH/11_1_msvc_RU.asm}

\myindex{x86!\Instructions!IDIV}
\IDIV делит 64-битное число хранящееся в паре регистров \TT{EDX:EAX} на значение в \ECX. 
В результате, \EAX будет содержать \glslink{quotient}{частное}, а \EDX --- остаток от деления. 
Результат возвращается из функции через \EAX, так что после операции деления, 
это значение не перекладывается больше никуда, 
оно уже там, где надо.

Из-за того, что \IDIV требует пару регистров \TT{EDX:EAX}, то перед этим инструкция \TT{CDQ} 
расширяет \EAX до 64-битного значения учитывая знак, так же, как это делает \MOVSX.

Со включенной оптимизацией (\Ox) получается:

\lstinputlisting[caption=\Optimizing MSVC,style=customasmx86]{\CURPATH/11_1_msvc_Ox.asm}

Это --- деление через умножение. Умножение конечно быстрее работает. 
Поэтому можно используя этот трюк
\footnote{Читайте подробнее о делении через умножение в \InSqBrackets{\HenryWarren 10-3}}
создать код эквивалентный тому что мы хотим и работающий быстрее.

В оптимизации компиляторов, это также называется 
\q{strength reduction}.

GCC 4.4.1 даже без включенной оптимизации генерирует примерно такой же код, 
как и MSVC с оптимизацией:

\lstinputlisting[caption=\NonOptimizing GCC 4.4.1,style=customasmx86]{\CURPATH/11_2_gcc.asm}
