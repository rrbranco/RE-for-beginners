\subsection{Weird loop optimization}

This is a simplest ever memcpy() function implementation:

\begin{lstlisting}[style=customc]
void memcpy (unsigned char* dst, unsigned char* src, size_t cnt)
{
	size_t i;
	for (i=0; i<cnt; i++)
		dst[i]=src[i];
};
\end{lstlisting}

At least MSVC 6.0 from the end of 1990s till MSVC 2013 can produce a really weird code (this listing is generated by MSVC 2013 x86):

\lstinputlisting[style=customasmx86]{advanced/500_loop_optimizations/1_1_EN.lst}

This is weird, because how humans work with two pointers? They store two addresses in two registers or two memory cells.
MSVC compiler in this case stores two pointers as one pointer (\IT{sliding dst} in \EAX) 
and difference between \IT{src} and \IT{dst} pointers (left unchanged over the span of loop body execution in \ESI).
When it needs to load a byte from \IT{src}, it loads it at \IT{diff + sliding dst} and stores byte
at just \IT{sliding dst}.

This has to be some optimization trick. But I've rewritten this function to:

\lstinputlisting[style=customasmx86]{advanced/500_loop_optimizations/1_2.lst}

\dots and it works as efficient as the \IT{optimized} version on my Intel Xeon E31220 @ 3.10GHz.
Maybe, this optimization was targeted some older x86 CPUs of 1990s era, since this trick is used at least by ancient MS VC 6.0?

Any idea?

\myindex{Hex-Rays}
Hex-Rays 2.2 have a hard time recognizing patterns like that (hopefully, temporary?):

\begin{lstlisting}[style=customc]
void __cdecl f1(char *dst, char *src, size_t size)
{
  size_t counter; // edx@1
  char *sliding_dst; // eax@2
  char tmp; // cl@3

  counter = size;
  if ( size )
  {
    sliding_dst = dst;
    do
    {
      tmp = (sliding_dst++)[src - dst];         // difference (src-dst) is calculated once, before loop body
      *(sliding_dst - 1) = tmp;
      --counter;
    }
    while ( counter );
  }
}
\end{lstlisting}

Nevertheless, this optimization trick is often used by MSVC (not just in \ac{DIY} homebrew \IT{memcpy()} routines,
but in many loops which uses two or more arrays),
so it's worth for reverse engineers to keep it in mind.

% <!-- As of why writting occurred after <b>dst</b> incrementing? -->

