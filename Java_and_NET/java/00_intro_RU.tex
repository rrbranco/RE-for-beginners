% TODO proof-reading
\subsection{Введение}

\newcommand{\JADURL}{\url{http://varaneckas.com/jad/}}

Есть немало известных декомпиляторов для Java (или для \ac{JVM}-байткода вообще)
\footnote{Например, JAD: \JADURL}.

Причина в том что декомпиляция \ac{JVM}-байткода проще чем низкоуровневого x86-кода:

\begin{itemize}
\item Здесь намного больше информации о типах.
      
\item Модель памяти в \ac{JVM} более строгая и очерченная.
\item Java-компилятор не делает никаких оптимизаций (это делает \ac{JVM} \ac{JIT} во время 
       исполнения), так что байткод в class-файлах легко читаем.
\end{itemize}

Когда знания \ac{JVM}-байткода могут быть полезны?

\newcommand{\URLListOfJVMLangs}{\url{http://en.wikipedia.org/wiki/List_of_JVM_languages}}

\begin{itemize}
\item Мелкая/несложная работа по патчингу class-файлов без необходимости снова компилировать результаты 
      декомпилятора.
\item Анализ обфусцированного кода.
\item Создание вашего собственного обфускатора.
\item Создание кодегенератора компилятора (back-end), создающего код для \ac{JVM} (как Scala, Clojure, итд
      \footnote{Полный список: \URLListOfJVMLangs}).
\end{itemize}

Начнем с простых фрагментов кода.

Если не указано иное, везде используется JDK 1.7.

Эта команда использовалась везде для декомпиляции class-файлов:\\
\GTT{javap -c -verbose}.

Эта книга использовалась мною для подготовки всех примеров: \JavaBook.

